# 기술 교육

국중진 멘토

2017.07.11
———————————————————————————

## Part 1: IoT Hub (ARTIK 710)


## Part 2: IoT End-Device (ARTIK 053)

———————————————————————————
	ARTIK Module

Hub 520, 1010 -> 중간 성능인 710이 추가 됨

053, 710이 삼성전자에서 밀고 있는 메인 모듈.


라즈베리파이의 경우에는 ADC(I/O)가 없지만 ARTIK은 지원하는 중.

아틱 053의 경우 자료가 별로 없음.
나눠준 자료가 이것에 대한 거의 모든 자료.
타이젠 RT라는 RTOS가 올라가 있음.
RTOS이기 때문에 개발 환경이 생소할 수 있음.

053의 경우 ARTIK IDE (ARTIK SDK)를 사용
710의 경우 Eclipse Che or Linux with ARTIK SDKs(C/C++/node.js)


	ARTIK Cloud Platform

아틱이 갖는 장점이 무엇이냐?
보안! 보안이 우수하다.
물리적인 칩 보안, 네트워크 보안, 클라우드 보안 등이 우수하다.
개발자나 사용자에겐 크게 와닿지 않는 부분. 특성이 모호하다.


기존 클라우드 플랫폼의 경우 스토리지의 개념이 많았음.
아틱 클라우드 플랫폼의 경우 메시지. 1KB. 센싱된 데이터를 수집하기 위한 클라우드. 메시지를 통해 액션을 취함.
이러한 룰을 설정할 수 있음. 이 기종의 디바이스가 상호작용할 수 있는 플랫폼을 제공한다.

아틱 디바이스에 연결된 것들을 소프트웨어로 식별한다. 각 기기의 ID값이 아니다.

	아틱 클라우드 기능
디바이스를 등록. 어떤 디바이스에 어떤 액션을 취해라하는 룰을 정의. 차트. 로그. 데이터 익스포트.


	710
라즈베리파이의 경우 안면인식을 할 경우 퍼포먼스가 떨어짐. 빌드타임이 길다. opencv를 처리하는데 오래 걸린다. 최대 5프레임.
아틱의 경우 BSP 안에 필요한 것들이 이미 올라와 있음. CPU 파워가 강해서 조금 더 빠름. 강력한 하드웨어적 성능.


센서, 액츄에이터가 제대로 동작하지 않을 경우 전압이 적절한지 확인해봐야 한다. (전압 세팅 확인)
MIPI 기반의 모듈이 없어도 HDMI를 사용하는 미니 모니터, USB 웹캠 등을 사용 가능.


아틱 7 Power
점퍼 세팅을 해주어야 함.
배터리와 어댑터의 세팅이 다름.
회로가 고장날 경우 판단이 어려움. 전원 부분을 다룰 때 신중할 필요가 있음.

터미널용 디버그 usb.
PC와 보드 연결.
아두이노 등 다른 상황에서는 위쪽에 연결한다.
기본적으로는 밑에 연결하면 된다.

USB를 꼽고 Power switch를 켜면 전원을 받고 있지만 부팅은 안 되는 상태.
하얀색 스위치를 1초 이상 누르고 있으면 부팅된다.



	GPIO
일반적인 목적의 시리얼 포트.
일반적으로 input, output 외에 다른 식으로도 작동할 수 있도록 해놓음.

	레지스터
 메모리 공간에 매핑을 시켜놓음.

	Sys file system
사용자가 시스템에 접근하기 위해선 system call로 밖에 접근할 수 없는 건데 이것을 이용해 접근하기 쉽게 해줌
    # cd /sys/class/gpio/gpio38
    # ls
확인할 수 있음.

symbolic link 'l' : 다른 파일을 가리키고 있다.

export라는 파일에 gpio index를 매겨줬더니 sys file system이 해당 포트와 연결해줌.
direction 파일에 in/out 타입을 적을 수 있다.
value라는 파일에 0이나 1을 써줌으로써 on/off를 설정할 수 있다.

	p58.
80핀이 인터페이스 보드에 구성되어 있음.
각각의 헤더별로 마킹되어 있음.
핀의 역할이 나와 있다.
vcc, ground -> 전원 구성

각각의 헤더별로 어떤 레지스터가 매핑되어 있는지 확인할 수 있음.
data sheet, skematic을 통해 확인할 수 있음.

	p59.
silk index - low level index - system level index가 다 다르다. 잘 확인해야함.

	p60.
아틱의 경우 아두이노와의 호환성을 제공하면서 아두이노 핀 넘버를 매겨 접근할 수 있게 해준다. 여기서 또하나의 index가 나옴.
2~11까지의 핀 넘버를 사용함.


	p66.
LED를 핀으로 직접 연결할 경우 위험하다.
5V를 걸어주면 LED의 작동을 확신하지 못 한다. 장비의 내부회로가 고장날 수 있으니 주의.
저항을 통해 anode, cathod가 견딜 수 있는 정도로 낮춰주어야 한다.
아두이노용 포트는 2번부터 시작하기 때문에 GPIO6을 8번으로 볼 수 있음.

	p67.
아틱 기반의 아두이노다 보니까 터미널로 보내는 것이 아니다.
이더넷을 사용해 보내던가, 파일 전송 유틸리티로 보내야함.
컴파일된 바이너리 내보내기 기능을 통해 이 파일을 아틱에 보내야함.
아틱에서는 이 파일의 퍼미션을 수정한 후 실행해주면 된다.
아틱의 아두이노 호환성 : 리눅스 환경에서 아두이노 펌웨어를 새로운 프로세스로 등록해서 실행하겠다.

	p70.
네트워크 업로드를 통해 올려주는 것도 가능하다. 아틱의 홈디렉토리로 올라감.

	p71.
watcher
    # /root/watcher &
watcher를 통해 아두이노의 시리얼 포트를 설정해 코드를 올리는 것처럼 사용가능.
하지만 usb포트를 하나 더 사용해야함.
종료
- ctrl + \ (quit)
- jobs -> # fg 1 -> ctrl + \
    - fg 명령어는 프로세스를 foreground 모드로 전환해줌.


아틱은 여러가지 프로그래밍 언어를 통해 접근할 수 있음.
방식만 약간 다르기 때문에 그것만 주의하면 된다.

ARTIK 예제는 File 기반으로 구현한 것으로 큰 의미는 없음.
sys file system 상의 I/O 예제는 다 같은 방식.

	ARTIK SDK
artik.io 홈페이지에서 받을 수 있음.
resource -> module documentation
software API
repository와 key값 관련 내용을 보고 진행해야 파일을 받을 수 있음.

sdk를 사용할 경우
	libartik-sdk-base(-devel)
	libartik-sdk-systemio(-devel)
이 두 개는 필수 설치.
(-devel까지 붙여서 설치를 하는 것이 좋음. 예제 파일도 제공)

	p89.
함수 포인터로 구현이 되어 있음. 매핑을 시켜주어야 함.
함수의 포인터 형태로 구현된 스트럭쳐(C), 추상메서드(C++), 인터페이스(Java)

온습도, 초음파, 모션 센셔와 같은 센서는 디지털 센서이기 때문에 High, Low가 반복이 됨.
얼마나 유지가 되느냐. 타이밍 특성이 중요하다. sys file system 접근 방식으로 접근할 경우
이것이 거의 불가능하기 때문에 아두이노 코드로 만들거나, SDK를 이용하는 것이 좋다.
아니면 Low level로 코딩을 해야되는 데 이것은 너무 간 것.


	p90.
전처리를 수행하고 object 파일을 만들고 링킹을 함. 그리고 로더에 대한 정보를 받아서 실행파일을 만들게 된다.
이 과정을 빌드라고 함. ARTIK은 프로세서가 ARM이기 때문에 arm- 컴파일러를 사용함. PC linux 환경에서 빌드를 할
경우 x16이기 때문에 flag가 필요함. 아틱에서는 gcc를 이용해 그냥 컴파일하면 된다.
Makefile의 대략적인 과정은 나중에 수정을 위해 알아두는 것이 좋다.


	p91.
	Programmable GPIOs
기본적으로 analog output은 없음.
PWM
- Pulse Width Modulation
- 펄스 폭을 조절해서 전압이 바뀌는 것과 같은 효과를 낸다.
ADC
- Analog to Digital Converter
- 6개의 채널 제공
GPIO
- Digital I/O
Serial
- PC and UART

센서 중 I2C, SPI 등을 이용하는 경우도 많아서 어떻게 이용할지 알아보는 것도 필요함.


	p93.
아날로그는 linear한 파형
공급되는 전압 대비 몇 가지의 값으로 표현을 할 수 있는가로 디테일을 확인함.
내가 사용하는 센서가 어떤 것이냐에 따라 산술 연산이 필요함.
reference voltage가 5v일 때와 비교해서 어떻게 변하는지 계산해야 한다.


--------- 1일차

	p93.
TMP36 온도 센서
1핀 전원.
2핀 센싱된 정보값, 아날로그.
3핀 그라운드.

아날로그센서 가변 저항, 조도센서, 온도센서

	p94.
온도에 따라 저항의 크기가 달라진다.
입력 대비 출력되는 전압은 달라짐.

	p95.
ADC의 경우도 sysfs를 통해 파일을 읽어 값을 확인할 수 있다.
12bit 범위의 resolution을 갖는 ADC가 내장되어 있음.
ADC raw(출력 전압)의 차이를 통해 온도를 유추해볼 수 있다.
이전 그래프를 볼 때 전압의 변화와 온도의 변화가 선형적으로 변하기 때문.

아두이노의 경우는 API를 제공하기 때문에 아날로그 포트의 값을 바로 확인할 수 있음.
sysfs의 c 예제에서는
하지만 클라우드로 데이터를 올려주고자 한다면 네트워크와 관련한 부분에서 조금 애매해질 수 있음.
c로 sysfs를 읽는 방식으로 개발하여 소켓을 통해 전달하는 것으로 해결.
아두이노를 사용하고 싶은 경우, 아두이노로 값을 읽고 이를 파이프를 이용하거나 공유 파일, 공유 메모리를 통해 해결해야 한다.

	p98.
데이터 시트를 통해 센서의 값과 다른 환경 변수의 관계가 표시되어 나온다. 이를 참고.
예) 빛의 밝기와 저항

	p99.
10단위의 수
0	1	2	3	4	5	6	7	8	9
흑	갈	적	주	노	초	파	보	회	흰
예) 갈 흑 주 - 삼색 띠
	10^3
저항의 값을 뺀 나머지만 ADC에 전달이 된다.
참고 : [링크](https://en.wikipedia.org/wiki/Electronic_color_code)

I2C
아틱 - 마스터
온도 센서 - 슬레이브
프로토콜을 가짐.
언제 쓸 것인지 언제 받아올 것인지에 대한 타이밍이 제공된다.
CLI 명령어 기반의 유틸리티를 사용한 책의 예제는 단순히 이 방식을 확인하기 위한 것.
아틱 SDK를 사용하는 것이 좋다.

아틱 기반의 아두이노 환경에서 센서를 테스트해보고 사용해야 한다.
모든 기능이 동일하게 작동하지는 않는다.

PWM
sysfs을 통해 인터페이스를 제공한다.
아틱 silk marking PWM0이 실제로는 PWM2로 정의되어 있음.
여러 개의 인덱스가 혼용 중. PWM2 포트를 활성화시켜야 한다.
period, duty cycle, enable의 파일이 생긴다.
앞의 두 가지는 nano sec 단위의 시간을 나타낸다. 마지막 변수는 flag.
직접 전압을 조절할 수 없기 때문에 period와 duty cycle을 조절하는 식의 방법을 이용한다.
50% duty cycle -  절반의 전압이 제공되는 효과.

	p108.
Makefile 없이 이 명령어만 쳐도 된다.
-I(대문자 I) 옵션은 include를 나타낸다.
default directory에 존재하지 않는 library를 사용할 때는 include시켜줘야 한다.
(/usr/lib에 있지 않은 것)
-l(소문자 L)를 통해 Library(sdk 위치)를 표시해줌.
표시해주지 않을 경우 unresolved symbol 에러가 난다.

	p109.
디지털 센서 중 온습도 센서
DHT11/22 핀의 구성은 동일.
11은 상온만 측정이 가능. 22는 영하도 가능.
출력할 때의 형식이 약간 차이가 있음.
3핀 NC(Not connected) : 사용하지 않음.

	p111.
아틱 보드 : MCU쪽
센서 파트 : DHT쪽

얼마나 high level을 유지시키느냐에 따라 0이냐 1이냐가 달라진다.
따라서 타이밍 특성을 맞추어 보내주어야 한다.
start signal을 보낸 후에 실제 데이터를 보낸다.

이러한 이유로 마이크로 세컨드 단위를 처리할 수 있는 로직이 필요하다.
파이썬의 경우 이러한 특성을 거의 맞추지 못함. c로 만든 라이브러리를 따로 찾아서 써야함..
그래서 c로 처음부터 짜는 것이 좋다.
타이밍 특성에 대한 고려가 필요하다.
타이밍 resolution을 제공하는 CPU냐 이런 것도 중요한데 요즘엔 하드웨어가 좋아서 대부분 지원.

하나의 포트에 대해 인풋 아웃풋이 바뀌는 것에 따라 온습도 측정이 가능.
총 40bit.
데이터 32bit. 상위 16bit는 습도, 하위 16bit는 온도.
시리얼하게 연달아 보내는 구조이다보니 타이밍이 잘못될 경우 데이터 해석이 잘못되는 상황이 발생함.
때문에 마지막 한 바이트를 checksum으로 사용한다.
이를 통해 잘못 보내거나 잘못 받은 것을 알아챌 수 있다.

	p115.
핀이 잘못되었음. 6번이다.
DHT22 예제이기 때문에 18 Micro seconds 이상으로 바꿔주어야함.
80 마이크로 세컨드를 유지한 후, 그 이후 받는 것이 데이터임.
value 함수
- 하나의 펄스를 읽어들이기 위한 것.
- 바이트 단위로 0과 1을 채워주고 shift해가면서 데이터를 완성한다.

Node-RED
UI 기반의 코딩 블록 사용.
소프트웨어 개발이 아닌 직관적인 툴을 사용하는 방식.
아틱 센서 제어 가능
센싱된 데이터를 클라우드로 올려주고 다른 디바이스와 상호작용할 수 있다.

범용적인 툴이기 때문에 아틱 전용의 블락을 추가해주어야 한다.
- 이 두 가지 모듈을 추가로 설치해주어야 한다.
	- node-red-contrib-artik
	- node-red-contrib-artik-cloud

cf. 사설 ip
192.168.xxx.xxx
10.xxx.xxx.xxx=
- 내부망 외부에서 접근 불가
netmask 255.255.255.0
8bit씩 나눠짐.


	아틱 클라우드
디바이스 별 ID를 확인하고 토큰을 발급 받아 저장해놔야 한다.
Device ID
- 클라우드에서 새로운 디바이스를 식별하기 위한 것
- 데이터를 올리거나 받아올 때도 사용함.

Device Type ID
- 새로운 타입의 디바이스를 만들었을 경우 자신이 등록해주어야 함.

Device token
- REST API를 호출하기 위한 과정에서 사용하기 위한 토큰
- 데이터를 올릴 때도 사용함.

해당 디바이스에 대한 Attribute를 등록할 수 있음. 이것을 차트로 확인 가능(모니터링).
실제로 어떤 데이터를 발생시키기 시작하면 노티가 나오면서 데이터가 찍히기 시작한다.
attribute 이름이 일치해야 데이터를 보내고 이를 받아서 확인할 수 있다.

아틱 클라우드는 단순히 데이터 저장을 위한 것이 아니다.
메시지 트랜스미션을 처리하기 위한 클라우드.
메시지와 액션을 받기 위한 것.
이 중 어떤 것을 받을 지 선택할 수 있음.

    dnf clean all

		dnf distort-sync —refresh

파일 확인
- /etc/yum.repos.d/fedora.repo
- fedora-update.repo


ARTIK Multimedia
보통의 리눅스, M플레이어를 많이 사용, S플레이, VLC 등.


ARTIK 7 - USB Camera
system 레이어에서 보통 다 해줌.
내부 버퍼에 저장된다. dmeg 커맨드로 확인 가능.

	p153.
OpenCV
아틱에 opencv가 올라가 있음. 따로 설치할 필요 없음.
`를 사용. 홑따옴표가 아니다.

실시간 스트리밍, cctv 같은 서비스를 만들고 싶을때?
ffserver 기능을 확인해보기


	p335.
예제 코드. example/artik\ cloud/
web socket을 사용하여 데이터를 교환할 때
처음에 registration 과정이 필요하다.
GPIO 모듈의 경우 라즈베리파이 환경에서만 테스트해봄.
아틱 환경에서 제대로 동작하는지 확인이 필요하다.



	소형 디바이스
라즈베리파이
- 35달러

라즈베리파이 제로
- 5달러
- usb 포트가 따로 없음
- 커넥티비티를 제공하지 못함
- 다른 라즈베리파이의 절반 크기

라즈베리파이 w
- 10달러
- 무선 기능이 적용됨.
- 제로와 사이즈가 같음.

파티클 포톤
- 와이파이 들어감
- GPIO
- 아두이노 호환
- 클라우드 연동

spark fun esp32 thing
- 와이파이 적용
- 20달러

설계까지 할 필요 없이 나와있는 것을 이용하는 것이 효율적이다.


	p164.
	ARTIK 053
- 나온 지 얼마 안 됨. 2달 정도.
- TIZEN RT OS가 올라가 있음.
TIZEN RT
- 나온 지 얼마 안 됨.

아틱 IDE
- windows용

아틱 053 환경에서는 어떤 방식으로 센서와 연결을 해야되며 어떻게 클라우드로 올릴 수 있을까?
이것이 포인트.

이벨루젼 키트
- 전체 보드

인터포져 보드
- CPU 포함된 곳

usb 커넥터를 통해 연결할 경우 DC전원을 굳이 연결 안 해도 된다.
아두이노 정도 급의 낮은 CPU 파워가 필요한 제품.
커넥티비티는 와이파이만 지원.
일반적인 인터페이스는 다 갖추고 있음.
아날로그를 사용하기 위해 AD컨버터를 따로 구성할 필요 없음.

	p169.
디폴트는 1,2. USB 전원.
DC파워를 사용하기 위해서는 3, 4 점퍼 이용.

	p170.
GPIO configuration
TIZEN RT source를 확인


Groove base shield 아두이노 호환용 쉴드 이용 가능.
센서를 패키지 형태로 모듈로 만들어 판매하는 경우 고가로 판매된다.

	p171.
JTAG
- ice(?) 관련해서 많이 사용했었음.
- 10년 전에 많이 사용.
- 어플리케이션을 만드는 수준에서는 별로 필요 없음.
임베디드 디버거 비쌈.

	ARTIK 053
크기 자체는 710과 비슷함.
장치 관리자를 통해 보면 JTAG, UART 두 가지가 나오게 된다.
Linux : /dev/ttyUSBx
Mac OS : /dev/tty.usbserial.xxx

리셋을 눌렀을 때 가만히 있으면 on-boarding mode로 돌게 된다.
	on-boarding mode
- softAP로 작동되면서 스마트폰과의 연결과 같은 형식으로 이용된다.
리셋 후 일정 시간 안에 키를 누르면 CLI 환경으로 작동된다.
	CLI mode
- 리눅스와 비슷해보이지만 다르다.
- 리눅스에서 사용했던 명령어의 대부분을 사용할 수 없음.


--------- 2일차

ARTIK 053
출력은 이루어지는데 키가 작동하지 않을 때(부팅만 될 때)
플로우 컨트롤을 none으로 바꿔주면 된다.

uboot 부트로더
- 대중화된 부트로더
- 오픈소스 기반
- 리눅스에 많이 적용되어 있다.

부트로더
운영체제가 동작할 수 있도록 운영체제 이미지를 적재시켜줌
CPU 클락 설정 등 설정을 해준다.


아무런 입력이 없으면 운영체제 이미지를 불러와서 작동함.

TIZEN OS
NuttX 라는 RTOS를 기반으로 만들어짐

MCU
- 마이크로 컨트롤러
- 예) AVR

운영체제는 소프트웨어
펌웨어는 하드웨어에 대한 제어를 수행한다.

주변 장치를 사용, 네트워크 처리, 블루투스 사용
프로토콜 스택이 필요하다. 하지만 아두이노에 모두 직접 올려 작업할 수는 없다. 부하가 커진다.
운영체제에 이를 모아놓고 호출해 쓸 수 있도록 만들어 놓은 것
운영체제가 제공하는 라이브러리, API를 통해 상위 레이어가 만들어진다.
펌웨어는 자기 마음대로 코드를 다 만들면 되지만 운영체제 위에 만들게 되면 운영체제에 종속적이게 된다.

RTOS가 정 마음에 들지 않을 경우 uboot 기반의 펌웨어를 만들어 싱글 테스크를 돌려도 된다. 하지만 어렵다..
RTOS를 접해보자.

리눅스 커널 코드
소스 코드 500MB -> 혼자 보기 힘들다.
일일이 분석하기가 쉽지 않다.

TIZEN RTOS
소스 코드의 사이즈가 작다.
범용 OS에 비해 심플하다. (스케쥴링 등)
리눅스를 모방해 만들어진 운영체제이다보니 이질감이 적다.

NuttX의 경우 문서가 어느 정도 있다. 나온지 10년 정도. 타이젠은 별로 없음. NuttX로 찾아보자.

p176.
SMART
- 소형의 IoT기기를 지원하기 위한 파일시스템
- nand flash

p177.
802.11.4 MAC + 6loWPAN
센서 네트워크를 위한 전용 프로토콜, 근거리 통신을 위한 저속 프로토콜
Zigbee, 6loWPAN

안정적으로 작동하는 지는 모르지만 공식적으로 대다수의 운영체제가 지원하는 기능을 지원한다.

다른 OS에서도 작동할 수 있도록 포팅 과정이 필요하다.
이것을 통해 만들어진 것이 TIZEN RT

자율주행차, IVI (in-vehicle infotainment)
백색 가전,
소형 가전, IoT 디바이스
이것들을 타이젠으로 커버하겠다.

NuttX를 기반으로
운영체제 기능을 지원,
사물인터넷, 작은 디바이스에 최적화되도록 수정한 커널
IoTivity를 지원한다.
OCF
light weight M2M
이 기종 디바이스들의 상호 운용성을 위한 프로토콜을 지원한다.

node.js의 경우 범용적으로 사용할 수 있음.
마찬가지로 타이젠은 node가 작용될 수 있는 환경을 제공하면서 응용 프로그램이 개발될 수 있는
최적의 환경을 제공하겠다는 목표로 만들어짐.
운영체제에 종속적인 어플리케이션을 만들 경우 타 운영체제에서 지원 불가
대부분의 경우 브라우저 엔진을 포함하고 있음.
HTML은 똑같은 컨텐츠를 볼 수 있기 때문에 브라우저 베이스의 어플리케이션을 만들 경우
다 똑같이 보여줄 수 있음.(HTML5 표준을 따르는 경우. 물론 플래시와 같은 기능은 제외)

p180.
wear-leveling
1~10만 번. 그 후 write가 불가능.
특정 블록에 쓰기가 반복되는 것을 막아줌.

journaling
복구와 관련된 기능

vfs
virtual file system

Proc fs, sys fs
디스크 상의 자원이 아니라 시스템의 추상화된, 혹은 물리적인 자원을 파일 시스템의 형태로 보여 준다.

MQTT, CoAP
사물인터넷을 위한 저전력 통신 프로토콜

강의자 사이트
참고 [링크] (cafe.naver.com/linuxdevdrv)


p181.
LWIP (low weight IP)

Tizen RT의 경우
IoTivity를 포함하고 있음.
LWM2M도 포함하고 있음.
하드웨어 인터페이스 제공.

p185.
BASH shell
(Born again shell)

TASH shell
(Tizen)
- 일반적인 쉘의 명령어 제공(ifconfig, ping 등)
- 이 디바이스에서 필요한 것을 다른 형태로 넣음.
- help를 통해 명령어 목록을 확인 가능.
- 인터페이스 정보가 다르게 나타난다. (wlan -> wl)


아틱 053의 경우 테스트를 위해 버튼 두 개, LED 두 개 제공

p187.
인덱스가 왜 다른 지 보여줌.
프로그램적으로 매핑되어 있다.

p188.
gpio read를 실행했을 때 버튼을 눌렀을 때 키 값이 0인지 1인지는 회로 구성에 따라 다르다.
ground를 어디에 두냐에 따라 달라진다.
값이 무엇인지는 상관없지만 구분이 되어야 한다.
TASH>>gpio read 44

p189.
dev 디렉토리에 장치 파일을 구성한다.
윈도우의 경우 com1, com2 레이블을 하는 식으로 구성한다.
하지만 리눅스에서는 장치 파일과 매핑하는 방식으로 표현. 장치이지만 파일로 접근할 수 있도록 추상화 해줌.
장치도 파일로 매핑을 하니 연산이 가능해진다.

블록 디바이스
스토리지 타입의 장치들. 데이터를 저장하기 위한 스토리지.
낸드 플래시

mksmartfs 명령어
- smart fs 구성을 해달라.

캐릭터 디바이스


가상 파일시스템은 모두 디렉토리와 파일의 형태로 해준다.

마운트
특정 대상과 파일 시스템을 매핑한다. (fat, vfat 등)
리눅스에서는 생략 가능. 에러 메시지가 나오면 지정해야함.
디렉토리를 만들고 마운트해야함.
명령어
- mount
- umount


RAM Disk
메모리의 일부를 디스크처럼 만들어줌.
ram0
ram1
ram2
디렉토리와 파일을 구성할 수 있음.
메모리에 대한 접근으로 속도가 빠르다.
Tizen RT의 경우 지원한다고 하는데 기본적으로는 지원하지 않는 것 같다.
설정을 변경해주어야할듯.


wifi 명령어
- wifi help
- AP모드 (softAP)
	- wifi startap
	- wifi stop
- (디바이스) 클라이언트 모드
	- wifi startsta
	- wifi stop
- wifi scan
- wifi connect

artikwifi 명령어
- artikwifi join
- artikwifi status
- 기본 커맨드가 아니다.
- 타이젠 풀소스를 빌드해서 만들어진 것

ifconfig wl1 dhcp 명령어
- 자동 IP 주소 할당

Tizen RT 풀 소스코드에서 명령어를 추가하거나 변경한 후
빌드하는 과정이 필요하다.


아틱 IDE
- 윈도우용 지원
- 아틱 각각의 SDK가 포함되어 있는 상태

p198.
JTAG 드라이버 설치
변경한 RT OS이미지를 아틱에 올릴 때 필요하다.
유틸리티를 통해 설치한다.

p200.
arm 프로세서를 사용하기 때문에 arm용 컴파일러, toolchain을 이용해야 한다.

OS 자체 버전이나 컴파일러 버전에 따라 안 되는 경우가 있을 수 있다.

정적 라이브러리
라이브러리를 어플리케이션에 포함시킨다.

동적 라이브러리
어플리케이션을 동작할 때 필요한 라이브러리를 포함시키지 않고 동적 링킹하게 된다.
만약 런타임에 라이브러리가 변경되었거나(버전) 없어졌을 경우 실행이 안 될 수 있음.
개발 환경이 달라지고 플랫폼, OS가 달라졌을 때 이러한 문제가 생긴다.
하지만 왜 죽었는지 이런 에러 메시지가 잘 안 뜨는 경우가 많다.


p201.
세 가지 모드를 골라 설치할 수 있다.
- minimal
- typical
- extra
필요없는 기능까지 넣을 필요는 없다.
하지만 리얼타임 이슈가 중요하지 않은 경우에는 typical 모드로 만들어주면 된다.

p202.
라이브러리에 대한 종속성을 없애기 위해 release 모드로 빌드한다.
최종 결과물의 사이즈, 퍼포먼스를 따져야 될 때 골라서 결정하게 된다.
아틱 053 하드웨어 스펙을 보면 성능이 좋지 않다.
임베디드 시스템의 경우 자원이 열악한 경우가 많기 때문에 빌드를 하는 과정에서 최적화를 해야 한다.
053 엔드 노드에서 최적화 이슈가 생길 경우 바이너리 사이즈를 줄여주기 위한 시도가 필요하다.
하나의 엔드 디바이스에서 다양한 작업을 처리하지 않도록 하는 것이 좋긴 하다.

p204.
IDE console 메뉴를 통해 putty, serial terminal을 이용하지 않고 아틱과 연결 가능

p206.
flashing
- 아틱에 쓰기
- 새 프로젝트일 경우 OS 이미지까지 통으로 빌드(전체 바이너리 업데이트)
- 어플리케이션 코드를 바꿀 때마다 그렇게 되는 것은 아니다. 이때는 어플리케이션 레이어만 바뀐다.

nand에 writing을 많이 하면 망가지게 된다. 실제 시스템의 경우 이런 것을 고려해야 한다.

p212.
Debug perspective
- open
- debug
	- 디버깅을 할 수 있는 모드로 진입
-

하나의 perspective는 여러 개의 view로 이루어져 있다.

step into, up 기능은 정상적으로 작동한다. 중단점 등을 사용하며 디버깅할 수 있음.

p213.
anode	cathode
+		-

Datasheet
forward current
- 전류

Peak forward current
- 최대 전류
- 고장나지 않는 범위를 확인할 수 있다.

회로가 고장나지 않는 물리적인 범위를 맞춰줘야 한다.

p215.
LED
떨어져 있는 것처럼 보임. 반도체.
문턱전압
트랜지스터에 스레시홀드 이상의 전압을 가하게 되면 갑자기 확 넘어간다. 전류가 흘러감.
Active high

트랜지스터
이 세 가지로 구성된다.
- 콜렉터
- 에미터
- 베이스
	- 전압을 공급시켜 흘려보낼 수 있게 하는 역할

p216.
트랜지스터를 빼고 구성할 수 있다.

p220.
디바이스 드라이버가 있어야 파일에 대한 처리가 가능하다. 없을 경우 파일처럼 보이기만 함.


Q. GPIO 입출력을 하기 위해 파일에 직접 쓰고 읽어야 되나?
A. 아니다. 다른 방식이 가능하다.

p221.
프로세스
- 프로그램을 실행시킬 경우 프로세스라고 함.
- 프로그램의 인스턴스, 살아있는 상태.

프로그램
- 스토리지 상에 존재하는 실행 가능한 파일
- 여러 가지 섹션으로 구성이 된다.
- 로더 스크립트에 설정이 정의되어 있음.
- 로더를 통해 메모리에 올린다.
- 동적으로 활성화되어 살아난다.

테스크
- 시스템이 보는 작업의 단위
- 패러럴하게 만들거나

프로세스, 테스크 등 작업의 단위를 어떻게 표현할 것인가
task_struct 스트럭쳐(구조체)


리눅스의 스트럭쳐를 보면 500줄.
스트럭쳐의 스트럭쳐를 거치다보면 리눅스의 구조가 보인다.


파일 디스크립터 넘버
stdin 0
stdout 1
stderr 2
3부터 시작함.

파일 디스크립터에 인터페이스, 추상 함수의 형태로 구성되어 있음.
결정되지 않은 형태라 바꾸어 쓸 수 있다.
파일에 대해 할 수 있는 것
- 오픈
- 읽고 쓰기
- 비동기 입출력
- 디렉토리 연산
- IO 컨트롤
공통의 인터페이스를 갖는 구조가 된다.
실제로 장치이냐 뭐냐에 따라 방법이 달라진다.
드라이버가 이를 결정해준다.

리눅스는 내부적으로 파일과 디렉토리를 구분하지 않는다.
내부에 파일을 가질 수 있으면 디렉토리


p224.
task, thread
프로세스 단위의 처리

tcb_s
테스크 그룹을 표현하기 위한 구조체

파일별로 어떠한 오퍼레이션을 제공하느냐
- 파일
- 스토리지, 블록
- 네임드 세마포어, 동기화
- 메시지 큐, 프로세스 간 통신
추상화시켜주는 메커니즘을 적용
파일의 유형을 네 가지로 구분하고 있음


p230.
타이젠에서는 아래와 같은 지연 함수를 사용.
- up_mdelay
- up_ndelay


p236.
마지막 바이트를 통해 데이터를 전달함.
0과 1이면 되는데(1bit) 문자열 0과 1로 이루어져 있어서
1byte를 사용 중이다. 하지만 이런 식으로 쓸 수밖에 없다.
드라이버가 인풋 아웃풋에 대한 인터페이스를 제공함.
형식을 제공한다.
바꾸고 싶으면 드라이버를 다시 만들어야 함.

0과 1 한 비트만 읽는 것만 필요한데 파일을 오픈하고 찾고 읽고 하는 과정을 계속 해야 해서
레이턴시가 늘어난다.
제대로 고칠 경우 상당 부분의 오버헤드가 사라진다.

키 값을 100ms당 한 번씩 읽어오는 중.
만약 1초에 천 번 인풋이 들어올 경우 제대로 읽을 수 없음.
1ms 단위로 읽어올 수 있어야 제대로 읽을 수 있다.

타이밍 이슈를 조절하느라 다른 작업이 영향을 받을 수 있다.
(잔물결)채터링 이슈가 바뀔 수 있음. 인풋이 한 번인데 여러 번처럼 읽어오는 경우.
오실로스코프와 같은 장비를 통해 고쳐야함.

p239.
매뉴얼하게 ap스캔하고 연결하고 했었는데 이러한 과정을 자동화시키는 예제.
이것을 활용하기 위한 API가 있는지 확인해보기

p244.
아날로그 채널이 여러 개이다 보니 다같이 받기 위해서 하나로 쓰고 있음.
0번 채널에 들어오는 아날로그 데이터만 받겠다라고 써놓음.
나노 세컨드 처리를 하기 위해서는 더 읽어오는 것이 작은 단위일 필요가 있다.

p248.
maximum과 minimum을 정의해놓고 있음.
pwm 제어를 위해서는 어떤 드라이버가 사용되냐. 어떤 API가 사용되냐.
를 확인해볼 수 있음.

p250.
모션 센서 예제
디지털 시그널을 기반으로 하는 센서

p252.
053의 경우 5v가 없음. 3.3v뿐이다.
만약 이 센서를 작동시키려고 하면 정상적인 작동을 하지 않는다.
전원에 대한 특성을 타는 센서
예로 초음파 센서도 5v가 필요.
DC모터 9~12v.
작동하지 않거나 작동하지만 이상한 값을 출력할 수 있음. 미리 확인하는 것이 필요하다.
센서가 필요로 하는 전압을 제공하기 위한 처리가 필요함.
릴레이, 외부 전원 등을 써야 한다.

p254.
움직임이 인식되면 LED를 켜겠다.

p256.
bit 연산을 함.
이전의 예제는 해당 파일을 열어서 처리를 함.
이 예제에서는 파일 관련 오퍼레이션이 없고 변수를 설정해 configgpio 함수를 이용함.
- s5j_gpiowrite
- s5j_gpioread
함수를 이용.
드라이버가 내부적으로 하는 작업이 이 작업이다.
low level에서는 GPIO 포트를 관리함.
이 예제에서는 특정 포트에 대한 사용을 직접 등록해 관리할 수 있음.

p257.
시그널이 있을 경우 LED를 켜겠다.
이런 식으로 코드를 작성할 경우 시간 동기를 제대로 맞추어 줄 수 있다.
예전처럼 파일을 열어서 처리할 경우 동기가 안 맞는 경우가 생김.
펌웨어 수준에서 코드 작성이 필요함.

초 단위 시간과 나노 타임 시간을 구조체로 만들어 나타내준다.
이것을 tm 스트럭쳐 타입으로 변화를 시켜서 strftime을 통해 원하는 스타일의 시간 타입 출력으로 변화시킨다.

p258.
초음파 센서 예제

p261.
10마이크로 세컨드를 유지하고 떨어뜨려야 함.
얼마나 high level이 유지가 되느냐. 이것을 구해서 거리를 구해낼 수 있다.




Trig 트리거를 통해 입력
Echo를 통해 출력

저항을 2:1로 만들어 놓음.
견딜 수 있는 전압의 범위를 알아놔야 한다.
출력이 5v로 나오는데 전압을 낮춰서 전달해주겠다.
1v가 들어오나 3v가 들어오나 high level이다.
GPIO 포트를 보호하기 위해 전압을 떨어뜨려서 전달해준다.

p263.
low level을 처리하는 매크로가 작성되어 있는 곳을 확인해줌.
이것을 보고 원하는 대로 만들어 쓴다.

p265.
low level 동안은 기다림.
high level 동안은 루프를 돈다. 1마이크로 세컨드 단위로 카운팅한다.
2초에 한 번씩 거리를 측정.

dev/gpio 파일을 가지고 이것을 해보기.
반복해서 리드를 하면서 타이밍 측정이 잘 되는지. 해보면 왜 이렇게 하는지 이해가 될 것.
타이밍 이슈가 크리티컬하다.

p271.
UART는 시리얼 포트와 충돌하는 이슈가 있어서 설명을 따로 안 함.


p283.
SPI
어떤 회로, 어떤 소자를 사용하는지 설명이 되어 있음.

p295.
ARTIK Cloud - 053

p296.
Tizen IDE 안에 예제가 포함되어 있음.
어떤 스트럭처와 API를 사용해야 하는지 참고할 필요가 있음.

Tizen RT 소스 상에 포함이 되어 있었음.
커널 쪽 소스라 IDE상에서 빌드가 안 됨.
리눅스 환경에서 빌드해야 함. 우분투를 권장. 우분투 예제만 지원 중.

p297.
빌드된 것을 플래시 하기 위해 dual rs232와 같은 것을 설치할 필요가 있음.

p298.
빌드하기 위해서는 어떤 플랫폼에서 동작하기 위한 소프트웨어인지, 어떤 것을 사용하고 사용하지 않는지 선택과정을 설명하는 설정이 필요하다.
커널이 빌드되는 환경을 어떻게 세팅할 것인지
board 타입
cfg 타입
- nettest(typical type)

p301.
usb를 통해 flashing.
리눅스에서 아틱053에 이미지를 업로드할 때
openocd를 활용.

p305.
다시 이미지를 빌드해서 올릴 경우 지금처럼 모든 기능이 활성화되어 있는 것이 아니다.
defconfig에 작성되어 있다.

y로 되어 있는지 확인할 것.
아예 없을 수도 있음.

p308.
만약 아예 없을 경우
make menuconfig으로 들어가서 필요한 부분에 체크해야 한다.

p312.
디바이스 아이디와 클라우드 유저를 연결시켜놓을 경우
나중에 별도의 처리가 필요 없다.

p313.
network protocol 관련 유틸리티도 설정 가능하다.

p314.
DM 관련 설정도 가능.
trouble shooting

p320.
디바이스 타입을 추가하는 예제

타이젠의 모든 기능을 사용해보고 싶으면 리눅스 상의 빌드 환경을 만들어 놓아야 한다.

--------- 3일차
———————————————————————————
